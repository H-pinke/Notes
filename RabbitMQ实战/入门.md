#### 第一章

Rabbitmq 本身及其所遵循的AMQP 协议中的一些细节做进一步的探究。

RabbitMq 的整体模型 架构如图

```
producer->Exchange->Queue->Consumer
```

RabbitMq 是一个消息代理器：它接受和转发消息。

你可以把它当作一个**邮局**：当你把邮件放在信箱里时，你可以肯定邮差先生最终会把邮件送到你的收件人哪里。RabbitMq 就是这里的邮箱，邮局和油差





```
$channel = $connection->channel();

```

接下来，我们创建一个通道，这是处理事情的大部分API的地方。

如果一个消费者中止了（其通道关闭，连接被关闭，或TCP连接丢失）不发送ACK，RabbitMQ将会理解这个消息并没有完全处理，将它重新加入队列。如果有其他用户同时在线，它就会快速地传递到另一个消费者。这样，即使意外中止了，也可以确保没有丢失信息



消息确认是默认关闭。可通过设置的第四个参数basic_consume设置为false（true意味着没有ACK）和从消费者发送合适的确认，一旦我们完成一个任务。



当RabbitMQ退出或崩溃了，会丢失队列和消息除非你不要。要确保消息不会丢失，需要两件事：我们需要将队列和消息都标记为持久的。



**消息持久化**

首先，我们需要确保RabbitMQ永远不会丢失队列。为了做到这一点，我们需要声明它是持久的。为此我们通过queue_declare作为第三参数为true：



**公平调度**

我们可以调用basic_qos方法，设置参数prefetch_count = 1。这告诉RabbitMQ不要在一个时间给一个消费者多个消息



###### 交换机

Rabbitmq 消息传递模型的核心思想是，生产者不发送任何消息直接到队列。事实上，生产者甚至不知道消息是否会发送到任何队列。

Exchange 做的事情很简单。一方面，它接收来自生产者的信息，另一边则推他们到队列。

那怎么推送到队列呢？应该附加到特定队列吗？它应该被添加到多个队列？还是应该抛弃呢？

**这个规则是由交换类型定义的**

有好几种

- direct 交换机背后的路由算法很简单-消息传递到队列，其绑定键完全匹配消息的路由键。

- topic

- headers

- fanout

    它只广播它收到的所有消息给它所知道的所有队列

#### 绑定（Bindings）

交换和队列之间的关系称为绑定。



#### 比喻

交换器相当于投递包裹的邮箱，

Routingkey 相当于填写在包裹上的地址

BindingKey 相当于包裹的目的地，

当填写在包裹上的地址和实际想要投递的地址相匹配时，那么这个包裹就会被正确投递到目的地，最后这个目的地的 主人 ---- 队列可以保留这个包裹。如果填写的地址出错，邮递员不能正确投递到目的地，包裹可能会 回退给寄件人，也有可能丢弃。



#### 如何保证消息的不重复消费

MQ 为了保证消息必达，消息上下半场均可能发送重复消息，如何保证消息的幂等性呢？

上半场：

此处重发的是 MQ-client 发起的，消息处理是MQ-server。对每条消息，MQ系统内部必须生成一个inner-msg-id 作为去重和幂等的依据。

这个ID全局唯一，业务无关，由MQ保证。



下半场：

此时重发时MQ-server 发起的，消息的处理是消息消费业务方，

业务发送方带入 biz-id，业务接收方去重保证幂等。

这个ID对单业务唯一，业务相关，对MQ透明。常见的有：支付ID、订单ID、帖子ID等。

结论：幂等性，不仅对MQ有要求，对业务上下游也有要求。