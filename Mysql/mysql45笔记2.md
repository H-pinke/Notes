### 一条SQL更新语句是如何执行的

前面我们说过了查询语句。那更新语句呢？可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。

和查询流程不一样的地方是，更新流程还涉及到两个重要的日志模块，它们正是我们今天要讨论的主角：redo log(重做日志或者物理日志) binlog（归档日志或者逻辑日志）

#### 重要的日志模块 redo log

举个例子： 酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。

如果有人要赊账或者还帐的话，掌柜一般有两种做法

- 一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉
- 另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。

写粉板和账本配合的整个过程，其实就是MYSQL 里经常说到的WAL技术，WAL的全称是Write-Ahead Logging 他的关键点就是先学日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。



InnodB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。

![](../image/redolog.jpg)

Write pos 的当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环到，擦除记录前要把记录更新到数据文件。

有了redo log，InnnoDB就可以保证即使数据库异常重启，之前提交的记录都不会丢失，这个能力称为**crash-safe**

##### 重要的日志模块 ：binlog

Mysql分为二块：

- 一块是server层，它主要做的是Mysql功能层面的时候，有自己的日志，称为binlog
- 一块是引擎层，负责存储相关的具体事宜。redo log是innoDB引擎特有的日志

这两种日志的不同点

1. redo log是innoDB 引擎特有的：binlog是Mysql的Server层实现的，所有引擎都可以使用。
2. Redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如给ID=2这个一行的c字段加1
3. Redo log 是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程

```
create table T(ID int primary key, c int);
update T set c=c+1 where ID=2;
```



1. 执行器先找引擎取ID=2这一行。ID是主键，引擎直接用数搜索找到这个一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的binlog，并把binlog写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交(commit)状态，更新完成。

这里我给出流程图，图中浅色框表示是在InnoDB 内部执行的，深色框表示是在执行器中执行的。

![](../image/binlog.png)

你可能注意到了，最后三步看上去有点“绕”，将redo log 的写入拆成了两个步骤：prepare和commit，这就是 **两阶段提交**

